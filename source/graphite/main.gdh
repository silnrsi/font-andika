/*
    Title:   Roman Font GDL description
    Authors: Martin Hosken, Bob Halllissy, Joan Wardell, Sharon Correll

	This file is from the Andika project (https://software.sil.org/andika/).
	Copyright (c) 2004-2025 SIL Global (http://www.sil.org/) with Reserved
	Font Names "Andika" and "SIL". This Font Software is licensed under the SIL
	Open Font License, Version 1.1 (http://scripts.sil.org/OFL).

    Changes:
AKW 2013-Mar-05  Remove Deprecated PUA feature
SJC 2005-May-16  Turn off AutoPseudo.
SJC 2005-May-10  Added a few comments.
JMW 2004-Jul-21  Comments on Viet, add 4th Eng.
RMH 10-Jul-2003  Added logic to decompose 1E2D and 1ECB in the context of upper diacritics.
MJPH 16-Nov-2002 Move overarch to down by -1200m from -700m.
*/

#include "stddef.gdh"

#define CHARISfont 1
#define DOULOSfont 2
#define GENTIUMBASICfont 3
#define GENTIUMBOOKBASICfont 4
#define GENTIUMfont 5
#define GENTIUMBOOKfont 6
#define ANDIKABASICfont 7
#define ANDIKAfont 8

/////#define GENBASICfamily (FONT == GENTIUMBASICfont || FONT == GENTIUMBOOKBASICfont)
#define BASIC (FONT == GENTIUMBASICfont || FONT == GENTIUMBOOKBASICfont || FONT == ANDIKABASICfont)
#define ANDIKAfamily (FONT == ANDIKAfont || FONT == ANDIKABASICfont)
#define GENTIUMfamily (FONT == GENTIUMBASICfont || FONT == GENTIUMBOOKBASICfont || FONT == GENTIUMfont || FONT == GENTIUMBOOKfont)

// Now turn on the font we want, so we get specific features. (This file is copied from
// something like doulos.gdh or charis.gdh by the build process.)
#include "fontSpecific.gdh"

#define DEBUG 0
// #define DEBUG 1  //jw 7/21/04 Use this to turn on DEBUG

#define SMALLCAPS 0

Bidi = 0;

// We handle double-encoded glyphs by hand, for the deprecated-PUA feature.
AutoPseudo = 0;

#define DIASTR3(x) [ x [ x x?]?]?
#define DIASTR4(x) [ x [ x [ x x?]?]?]?
#define DIASTR5(x) [ x [ x [ x [ x x?]?]?]?]?
#define attached	user1

// user1 - user4 are used in pitches.gdh
// user1 is used by both pitch and attachment stuff because there should not be any conflict.
// user2 is used by both pitch and low-profile stuff because there should not be any conflict.

#define needs_lp	user2

// #define pua		user5

#define LP_DIACONLY 0
#define LP_BASEONLY 1
#define LP_BASEDIAC 2

////#define KERNPASS 3

#if DEBUG
#define DeBuG g__ltn_cap_d g__ltn_sm_e g__ltn_cap_b g__ltn_sm_u g__ltn_cap_g g__colon
#endif

//////////////////////////////////////////////////////////////////////////////////////
//
//	Glyphs
//

table(glyph);

// To make upstream whitespace be reordered at the end of a line; shouldn't be
// needed if compiler is working correctly.
//clsSpaces = (g_space, g2000, g2001, g2002, g2003, g2004, g2005
//				g2006, g2007, g2008, g2009, g200A, g200B)
//			{ dir = DIR_WHITESPACE };


// Temp additions by David Raymond

// cBarBowl = (g__ltn_sm_b_barred_bowl, g__ltn_sm_d_barred_bowl, g__ltn_sm_g_barred_bowl);

// cno_BarBowl = (g__ltn_sm_b_barred_stem, g__ltn_sm_d_barred_stem, g__ltn_sm_g_strk);



// Additions to feature classes for small caps; these are not included
// automatically by make_gdl.

cBaselineHook += (g__ltn_sm_eng_baseline_hook_sc); // but these classes aren't really used
cUCStyle += (g__ltn_sm_eng_u_c_style_sc);
cKom += (g__ltn_sm_eng_kom_sc);
cno_BaselineHook += (g__ltn_sm_eng_sc);
cno_UCStyle += (g__ltn_sm_eng_sc);
cno_Kom += (g__ltn_sm_eng_sc);

// This class is not useful since there are two different features that use "topBar":
//cTopBar += (g0253_topBar_sc);
//cno_TopBar += (g0253_sc);

cTopBarB = (g__ltn_sm_b_hook_top_bar, g__ltn_cap_b_hook_top_bar, g__ltn_sm_b_hook_top_bar_sc);
cno_TopBarB = (g__ltn_sm_b_hook, g__ltn_cap_b_hook, g__ltn_sm_b_hook_sc);

cTopBarD = (g__ltn_cap_d_hook_top_bar, g__ltn_sm_d_hook_top_bar_sc);
cno_TopBarD = (g__ltn_cap_d_hook, g__ltn_sm_d_hook_sc);

cVertStrk += (g__ltn_sm_h_strk_vert_strk_sc);
cno_VertStrk += (g__ltn_sm_h_strk_sc);

//cCommaStyle += (g_scedilla_comma_style_sc, g0163_commaStyle_sc);
//cno_CommaStyle += (g_scedilla_sc, g0163_sc);

cTopSerif += (g__ltn_sm_opn_o_top_serif_sc);
cno_TopSerif += (g__ltn_sm_opn_o_sc);

cLCStyleNhook = (g__ltn_cap_n_lft_hook_l_c_style, g__ltn_sm_n_lft_hook_l_c_style_sc);
cno_LCStyleNhook = (g__ltn_cap_n_lft_hook, g__ltn_sm_n_lft_hook_sc);

cLCStyleRtail = (g__ltn_cap_sm_r_hook_tail, g__ltn_sm_cap_sm_r_hook_tail); // what about lowercase r-tail SC?
cno_LCStyleRtail = (g__ltn_cap_r_hook_tail, g__ltn_sm_r_hook_tail_sc);

cRtHookThook = (g__ltn_cap_t_hook_rt_hook, g__ltn_sm_t_hook_rt_hook_sc);
cno_RtHookThook = (g__ltn_cap_t_hook, g__ltn_sm_t_hook_sc);

cRtHookYhook = (g__ltn_cap_y_hook_rt_hook, g__ltn_sm_y_hook_rt_hook_sc);
cno_RtHookYhook = (g__ltn_cap_y_hook, g__ltn_sm_y_hook_sc);

cStraightLft += (g__ltn_sm_v_hook_straight_lft_sc);
cStraightLftHighHook += (g__ltn_sm_v_hook_straight_lft_high_hook_sc);
cno_StraightLft += (g__ltn_sm_v_hook_sc);
cno_StraightLftHighHook += (g__ltn_sm_v_hook_sc);

cRevSigmaStyle += (g__cy_sm_abkhas_dze_rev_sigma_style_sc, g__ltn_sm_ezh_rev_sigma_style_sc);
cno_RevSigmaStyle += (g__cy_sm_abkhas_dze_sc, g__ltn_sm_ezh_sc);

cOpenTop += (g__ltn_sm_ou_open_top_sc);
cno_OpenTop += (g__ltn_sm_ou_sc);

cMongolStyle += (g__cy_sm_e_mongol_style_sc);
cno_MongolStyle += (g__cy_sm_e_sc);

cLrg += (g__ltn_sm_saltillo_lrg_sc);
cno_Lrg += (g__ltn_sm_saltillo_sc);

cRetroHook += (
		g__ltn_sm_a_ogonek_retro_hook_sc,	g__ltn_sm_a_ogonek_sng_story_retro_hook_sc,	g__ltn_sm_e_ogonek_retro_hook_sc,
		g__ltn_sm_i_ogonek_retro_hook_sc,	g__ltn_sm_u_ogonek_retro_hook_sc, 			g__ltn_sm_o_ogonek_retro_hook_sc,			g__ltn_sm_o_ogonek_macron_retro_hook_sc);
cno_RetroHook += (
		g__ltn_sm_a_ogonek_sc,					g__ltn_sm_a_ogonek_sng_story_sc,			g__ltn_sm_e_ogonek_sc,
		g__ltn_sm_i_ogonek_sc,					g__ltn_sm_u_ogonek_sc,					g__ltn_sm_o_ogonek_sc,					g__ltn_sm_o_ogonek_macron_sc);



cVN += (g__ltn_sm_a_circum_acute_v_n_sc,	g__ltn_sm_a_circum_grave_v_n_sc,	g__ltn_sm_a_circum_tilde_v_n_sc,	g__ltn_sm_a_circum_hook_abv_v_n_sc,
		g__ltn_sm_a_breve_acute_v_n_sc,	g__ltn_sm_a_breve_grave_v_n_sc,	g__ltn_sm_a_breve_tilde_v_n_sc,	g__ltn_sm_a_breve_hook_abv_v_n_sc,
		g__ltn_sm_a_circum_acute_sng_story_v_n_sc,	g__ltn_sm_a_circum_grave_sng_story_v_n_sc,	g__ltn_sm_a_circum_tilde_sng_story_v_n_sc,	g__ltn_sm_a_circum_hook_abv_sng_story_v_n_sc,
		g__ltn_sm_a_breve_acute_sng_story_v_n_sc,	g__ltn_sm_a_breve_grave_sng_story_v_n_sc,	g__ltn_sm_a_breve_tilde_sng_story_v_n_sc,	g__ltn_sm_a_breve_hook_abv_sng_story_v_n_sc,
		g__ltn_sm_e_circum_acute_v_n_sc,	g__ltn_sm_e_circum_grave_v_n_sc,	g__ltn_sm_e_circum_tilde_v_n_sc,	g__ltn_sm_e_circum_hook_abv_v_n_sc,	g__ltn_sm_o_circum_acute_v_n_sc,	g__ltn_sm_o_circum_grave_v_n_sc,	g__ltn_sm_o_circum_tilde_v_n_sc,	g__ltn_sm_o_circum_hook_abv_v_n_sc);

cno_VN += (g__ltn_sm_a_circum_acute_sc,	g__ltn_sm_a_circum_grave_sc,		g__ltn_sm_a_circum_tilde_sc,		g__ltn_sm_a_circum_hook_abv_sc,
		g__ltn_sm_a_breve_acute_sc,		g__ltn_sm_a_breve_grave_sc,		g__ltn_sm_a_breve_tilde_sc,		g__ltn_sm_a_breve_hook_abv_sc,
		g__ltn_sm_a_circum_acute_sng_story_sc,		g__ltn_sm_a_circum_grave_sng_story_sc,		g__ltn_sm_a_circum_tilde_sng_story_sc,		g__ltn_sm_a_circum_hook_abv_sng_story_sc,
		g__ltn_sm_a_breve_acute_sng_story_sc,		g__ltn_sm_a_breve_grave_sng_story_sc,		g__ltn_sm_a_breve_tilde_sng_story_sc,		g__ltn_sm_a_breve_hook_abv_sng_story_sc,
		g__ltn_sm_e_circum_acute_sc,		g__ltn_sm_e_circum_grave_sc,		g__ltn_sm_e_circum_tilde_sc,		g__ltn_sm_e_circum_hook_abv_sc,		g__ltn_sm_o_circum_acute_sc,		g__ltn_sm_o_circum_grave_sc,		g__ltn_sm_o_circum_tilde_sc,		g__ltn_sm_o_circum_hook_abv_sc);


// Why is there no g_lcaron_caron_sc??

// Give a better name:
c_sc = csc;


// Classes of double-diacritics above and below:
cUDblDia = (g__comb_dbl_breve  g__comb_dbl_macron  g__comb_dbl_tilde  g__comb_dbl_inv_breve  g__comb_dbl_diaer  g__comb_dbl_circum);
cLDblDia = (g__comb_dbl_macron_blw  g__comb_dbl_rt_arrw_blw  g__comb_dbl_breve_blw);


// Various classes of diacritics; the classes generated by make_gdl are not helpful.
cBDia = (cLDia cODia cHDia);				// Below = Lower + Ogonek + Cedilla
cnBDiaX = (cUDia cRDia);					// Not Below
cnHDiaX = (cLDia cODia cRDia cUDia);		// Not Cedilla
cnLDiaX = (cHDia cODia cRDia cUDia);		// Not Lower
cnODiaX = (cHDia cLDia cRDia cUDia);		// Not Ogonek
cnRDiaX = (cHDia cLDia cODia cUDia);		// Not Horn (right)
cnUDiaX = (cHDia cLDia cODia cRDia );		// Not Upper
cDia =  (cHDia cLDia cODia cRDia cUDia);	// Any (but not double dias)

// ff, fi, fl ligatures

cfLigC2 = (g__ltn_sm_f  g__ltn_sm_i  g__ltn_sm_l);
cfLig  = (g__ltn_lig_sm_f_sm_f  g__ltn_lig_sm_f_sm_i  g__ltn_lig_sm_f_sm_l);
cffLigC3 = (g__ltn_sm_i  g__ltn_sm_l);
cffLig = (g__ltn_lig_sm_f_sm_f_sm_i  g__ltn_lig_sm_f_sm_f_sm_l);

cfLigC2_sItal  = (g__ltn_sm_f_s_ital, g__ltn_sm_i_s_ital, g__ltn_sm_l_s_ital);
cfLig_sItal    = (g__ltn_lig_sm_f_sm_f_s_ital, g__ltn_lig_sm_f_sm_i_s_ital, g__ltn_lig_sm_f_sm_l_s_ital);
cffLigC3_sItal = (g__ltn_sm_i_s_ital, g__ltn_sm_l_s_ital);
cffLig_sItal   = (g__ltn_lig_sm_f_sm_f_sm_i_s_ital, g__ltn_lig_sm_f_sm_f_sm_l_s_ital);

cfLig_all = (cfLig  cfLig_sItal)
	{ component {f1 = box(0, -descent, aw/2, ascent); f2 = box(aw/2, -descent, aw, ascent) }};
cffLig_all = (cffLig  cffLig_sItal)
	{ component { f1 = box(0, -descent, aw/3, ascent);
					f2 = box(aw/3, -descent, (2*aw)/3, ascent);
					f3 = box((2*aw)/3, -descent, aw, ascent) }}

cSpecialDotted = (g__ltn_sm_i_tilde_blw  g__ltn_sm_i_dot_blw);		// i with lower diacritics
cSpecialDottedDia = (g__comb_tilde_blw  g__comb_dot_blw);


// Special class defs for cedilla compositions that are rendered as commaaccent:
cCedillaBase = (g__ltn_cap_g  g__ltn_sm_g  g__ltn_cap_k  g__ltn_sm_k  g__ltn_cap_l  g__ltn_sm_l  g__ltn_cap_n  g__ltn_sm_n  g__ltn_cap_r  g__ltn_sm_r);
cCedillaComposite = (g__ltn_cap_g_cedilla g__ltn_sm_g_cedilla g__ltn_cap_k_cedilla g__ltn_sm_k_cedilla
		g__ltn_cap_l_cedilla	g__ltn_sm_l_cedilla g__ltn_cap_n_cedilla g__ltn_sm_n_cedilla g__ltn_cap_r_cedilla
		g__ltn_sm_r_cedilla);

// Add in other cedilla composites:
cCedillaBase += (g__ltn_cap_c  g__ltn_sm_c  g__ltn_cap_s  g__ltn_sm_s  g__ltn_cap_t  g__ltn_sm_t  g__ltn_cap_e  g__ltn_sm_e  g__ltn_sm_s_sc  g__ltn_sm_t_sc)
cCedillaComposite += (g__ltn_cap_c_cedilla g__ltn_sm_c_cedilla g__ltn_cap_s_cedilla g__ltn_sm_s_cedilla
		g__ltn_cap_t_cedilla  g__ltn_sm_t_cedilla  g__ltn_cap_e_cedilla  g__ltn_sm_e_cedilla  g__ltn_sm_s_cedilla_sc  g__ltn_sm_t_cedilla_sc)

// Ogonek composites:
cOgonekBase = (g__ltn_cap_a  g__ltn_sm_a  g__ltn_cap_e  g__ltn_sm_e  g__ltn_cap_u  g__ltn_sm_u  g__ltn_cap_o  g__ltn_sm_o  g__ltn_cap_o_macron  g__ltn_sm_o_macron);
cOgonekComposite = (g__ltn_cap_a_ogonek g__ltn_sm_a_ogonek g__ltn_cap_e_ogonek g__ltn_sm_e_ogonek g__ltn_cap_u_ogonek
		g__ltn_sm_u_ogonek  g__ltn_cap_o_ogonek  g__ltn_sm_o_ogonek  g__ltn_cap_o_ogonek_macron  g__ltn_sm_o_ogonek_macron);

// Horn composites:
cHornBase = (g__ltn_cap_o  g__ltn_sm_o  g__ltn_cap_u  g__ltn_sm_u);
cHornComposite = (g__ltn_cap_o_horn  g__ltn_sm_o_horn  g__ltn_cap_u_horn  g__ltn_sm_u_horn);

// Modifier superscripts that require smaller diacritics:
cModSuper = (g__mod_sm_h  g__mod_sm_h_hook  g__mod_sm_j  g__mod_sm_r  g__mod_sm_trnd_r  g__mod_sm_trnd_r_hook  g__mod_sm_cap_inv_r  g__mod_sm_w  g__mod_sm_y
		g__mod_glottal_stop  g__mod_rev_glottal_stop  g__mod_sm_gamma  g__mod_sm_l  g__mod_sm_s  g__mod_sm_x  g__mod_sm_rev_glottal_stop
		g__mod_cap_a  g__mod_cap_ae  g__mod_cap_b  g__mod_cap_barred_b
		g__mod_cap_d  g__mod_cap_e  g__mod_cap_rev_e  g__mod_cap_g  g__mod_cap_h  g__mod_cap_i  g__mod_cap_j  g__mod_cap_k
		g__mod_cap_l  g__mod_cap_m  g__mod_cap_n  g__mod_cap_rev_n  g__mod_cap_o  g__mod_cap_ou  g__mod_cap_p  g__mod_cap_r
		g__mod_cap_t  g__mod_cap_u  g__mod_cap_w  g__ltn_sup_sm_a  g__ltn_sup_sm_turned_a  g__ltn_sup_sm_alpha  g__mod_sm_trnd_ae  g__ltn_sup_sm_b
		g__ltn_sup_sm_d  g__ltn_sup_sm_e  g__ltn_sup_sm_schwa  g__ltn_sup_sm_opn_e  g__mod_sm_trnd_opn_e  g__ltn_sup_sm_g  g__mod_sm_trnd_i  g__ltn_sup_sm_k
		g__ltn_sup_sm_m  g__ltn_sup_sm_eng  g__ltn_sup_sm_o  g__ltn_sup_sm_opn_o  g__mod_sm_top_half_o  g__mod_sm_bottom_half_o  g__ltn_sup_sm_p  g__ltn_sup_sm_t
		g__ltn_sup_sm_u  g__mod_sm_sdwys_u  g__ltn_sup_sm_turned_m  g__ltn_sup_sm_v  g__mod_sm_ain  g__mod_sm_beta  g__mod_sm_gr_gamma  g__mod_sm_delta  g__mod_sm_gr_phi  g__mod_sm_chi  g__mod_cy_sm_en
		g__ltn_sup_sm_turned_alpha  g__mod_sm_c  g__ltn_sup_sm_c_curl  g__mod_sm_eth  g__ltn_sup_sm_rev_opn_e
		g__ltn_sup_sm_f  g__ltn_sup_sm_dotless_j_strk  g__ltn_sup_sm_script_g  g__mod_sm_turned_h  g__ltn_sup_sm_i_strk  g__mod_sm_iota  g__ltn_sup_sm_cap_i  g__mod_sm_cap_i_strk
		g__mod_sm_j_crossed_tail  g__ltn_sup_sm_l_retr_hook  g__mod_sm_l_pal_hook  g__mod_sm_cap_l  g__mod_sm_m_hook  g__ltn_sup_sm_turned_m_lng_leg  g__ltn_sup_sm_n_lft_hook  g__mod_sm_n_retr_hook
		g__mod_sm_cap_n  g__ltn_sup_sm_barred_o  g__mod_sm_phi  g__mod_sm_s_hook  g__ltn_sup_sm_esh  g__mod_sm_t_pal_hook  g__ltn_sup_sm_u_bar  g__ltn_sup_sm_upsilon
		g__mod_sm_cap_u  g__mod_sm_v_hook  g__ltn_sup_sm_turned_v  g__ltn_sup_sm_z  g__mod_sm_z_retr_hook  g__ltn_sup_sm_z_curl  g__ltn_sup_sm_ezh  g__mod_sm_theta  g__ltn_sup_sm_i  g__ltn_sup_sm_n
		g__ltn_sup_sm_i_dotless  g__mod_sm_j_dotless  g__ltn_sup_sm_i_strk_dotless  g__mod_sm_j_crossed_tail_dotless g__mod_sm_cap_h_dbl_strk);

// Modifier subscripts that require smaller diacritics:
cModSub = (g__ltn_sub_sm_i  g__ltn_sub_sm_r  g__ltn_sub_sm_u  g__ltn_sub_sm_v  g__gr_sub_sm_beta  g__gr_sub_sm_gamma  g__gr_sub_sm_rho  g__gr_sub_sm_phi  g__gr_sub_sm_chi
		g__ltn_sub_sm_a  g__ltn_sub_sm_e  g__ltn_sub_sm_o  g__ltn_sub_sm_x  g__ltn_sub_sm_schwa
		g__ltn_sub_sm_i_dotless);

// Vietnamese diacritic combinations

#if (FONT == GENTIUMfont)
c0302_noVN = (g__comb_circum  g__comb_circum_l_p);
#else
c0302_noVN = (g__comb_circum);
#endif

c0306_noVN = (g__comb_breve);

cDiac_noVN = (g__comb_acute		g__comb_grave		g__comb_hook_abv 	g__comb_tilde);
c_0302_DiacVN = (	g__comb_circum_acute_v_n		g__comb_circum_grave_v_n
					g__comb_circum_hook_v_n	g__comb_circum_tilde_v_n);
c_0306_DiacVN = (	g__comb_breve_acute_v_n		g__comb_breve_grave_v_n
					g__comb_breve_hook_v_n	g__comb_breve_tilde_v_n);

#if (FONT == GENTIUMfont)
cno_LP += (	g__comb_circum_acute_v_n		g__comb_circum_grave_v_n		g__comb_circum_tilde_v_n		g__comb_circum_hook_v_n
			g__comb_breve_acute_v_n		g__comb_breve_grave_v_n		g__comb_breve_tilde_v_n );
cLP += 	(	g__comb_circum_acute_v_n_l_p	g__comb_circum_grave_v_n_l_p	g__comb_circum_tilde_v_n_l_p	g__comb_circum_hook_v_n_l_p
			g__comb_breve_acute_v_n_l_p	g__comb_breve_grave_v_n_l_p	g__comb_breve_tilde_v_n_l_p );
#endif

// Precomposed base + first diac
c_baseCircum = (g__ltn_cap_a_circum, g__ltn_sm_a_circum, g__ltn_cap_e_circum, g__ltn_sm_e_circum,
				g__ltn_cap_i_circum, g__ltn_sm_i_circum, g__ltn_cap_o_circum, g__ltn_sm_o_circum,
				g__ltn_cap_u_circum, g__ltn_sm_u_circum);
c_baseBreve  = (g__ltn_cap_a_breve, g__ltn_sm_a_breve, g__ltn_cap_e_breve, g__ltn_sm_e_breve,
				g__ltn_cap_i_breve, g__ltn_sm_i_breve, g__ltn_cap_o_breve, g__ltn_sm_o_breve, g__ltn_cap_u_breve, g__ltn_sm_u_breve);
c_base_noDiac = (g__ltn_cap_a, g__ltn_sm_a, g__ltn_cap_e, g__ltn_sm_e, g__ltn_cap_i, g__ltn_sm_i, g__ltn_cap_o, g__ltn_sm_o, g__ltn_cap_u, g__ltn_sm_u);

// Vietnamese/literacy combinations

// a with stacked diacritics
c_aStack_noLit = (g__ltn_sm_a_circum_acute  g__ltn_sm_a_circum_grave  g__ltn_sm_a_circum_hook_abv  g__ltn_sm_a_circum_tilde  g__ltn_sm_a_breve_acute  g__ltn_sm_a_breve_grave  g__ltn_sm_a_breve_tilde  g__ltn_sm_a_breve_hook_abv); // eg, a+circum+acute
c_diacComb_vN = (g__comb_circum_acute_v_n, g__comb_circum_grave_v_n,
			g__comb_circum_hook_v_n, g__comb_circum_tilde_v_n,
			g__comb_breve_acute_v_n, g__comb_breve_grave_v_n,
			g__comb_breve_hook_v_n, g__comb_breve_tilde_v_n);


// These caron combinations are treated specially by European languages, which is the default:
cCaronEuro = (g__ltn_sm_d_caron, g__ltn_sm_l_caron, g__ltn_cap_l_caron, g__ltn_sm_l_caron_sc, g__ltn_sm_t_caron);
cno_CaronEuro = (g__ltn_sm_d, g__ltn_sm_l, g__ltn_cap_l, g__ltn_sm_l_sc, g__ltn_sm_t);

// These work for Doulos:
g__ltn_sm_d_caron {comp {base = box(0, bb.bottom-50m, (3*aw)/4, bb.top+50m);
                caron = box((3*aw)/4, bb.top - 450m, aw,bb.top+50m) }};

g__ltn_sm_l_caron {comp {base = box(0,bb.bottom-70m, (2*aw)/3, bb.top+50m);
                caron = box((5*aw)/8, bb.top - 450m, aw,bb.top+50m) }};

g__ltn_cap_l_caron {comp {base = box(0,bb.bottom-50m, aw/2+70m, bb.top+50m);
                caron = box(bb.right-450m, bb.top-500m, bb.right-200m,bb.top+50m) }};

g__ltn_sm_l_caron_sc {comp {base = box(0,bb.bottom-50m, aw/2+70m, bb.top+50m);
                caron = box(bb.right-450m, bb.top-500m, bb.right-100m,bb.top+50m) }};

g__ltn_sm_t_caron {comp {base = box(0,bb.bottom-50m, bb.right-200m, bb.top-200m);
                caron = box(bb.right-300m, bb.top-450m, bb.right+50m, bb.top+50m) }};

// Uppercase-eng variations
// (The extra composite glyphs aren't really needed, they only happen to be in the font for AAT.)
c_eng_Descender = (g__ltn_cap_eng, g__ltn_sm_eng_sc);                    // cno_BaselineHook = cno_Kom
c_eng_UCStyle = (g__ltn_cap_eng_u_c_style, g__ltn_sm_eng_u_c_style_sc);  // (g__eng_u_c_style, g014A0301_uCStyle, g014A0300_uCStyle, g014A0302_uCStyle, g014A0303_uCStyle, g014A0323_uCStyle);
c_eng_BaselineHook = (g__ltn_cap_eng_baseline_hook, g__ltn_sm_eng_baseline_hook_sc);  // cBaselineHook;
c_eng_Kom = (g__ltn_cap_eng_kom, g__ltn_sm_eng_kom_sc);                  // cKom;

// V-hook variations
c_vhook_Curved = cno_StraightLft; // = cno_StraightLftHighHook
c_vhook_StraightLeft = cStraightLft;
c_vhook_HighHook = cStraightLftHighHook;

// Cyrillic shha (uses same tag as uppercase eng so we define these clases by hand):
cUCStyleCyrShha = (g__cy_sm_shha_u_c_style);
cno_UCStyleCyrShha = (g__cy_sm_shha);

// We need to add these explicitly because makegdl does not recognize the fact that
// 'g_dotlessi_s_italic' needs to be in the cDotless class.
// TODO: recheck when we switch over to the new version of make_gdl.
cDotless += (g__ltn_sm_dotless_i_s_ital); // g_dotlessi_tail_i;
cno_Dotless += (g__ltn_sm_i_s_ital);     // g_i_tail_i;

// Same with tail-i and j-serif.
#if (ANDIKAfamily)
cDotless    += (g__ltn_sm_dotless_i_tail_i	g__ltn_sm_dotless_j_top_lft_serif);
cno_Dotless += (g__ltn_sm_i_tail_i			g__ltn_sm_j_top_lft_serif);
#endif

// Same with the low-profile i and j.
#if (FONT == GENTIUMfont)
cDotless    += (g__ltn_sm_i_dotless	g__ltn_sm_j_dotless);
cno_Dotless += (g__ltn_sm_i_l_p		g__ltn_sm_j_l_p);

// Also handle converting low-profile i/j to small caps.
cno_sc	+= (g__ltn_sm_i_l_p		g__ltn_sm_j_l_p);
c_sc	+= (g__ltn_sm_i_sc		g__ltn_sm_j_sc);
#endif

#if (ANDIKAfamily)
// makegdl can't figure out that 'g_q_diag_tail_sc' needs to be in the cDiagTail class.
cno_DiagTail += (g__ltn_sm_q_sc);
cDiagTail    += (g__ltn_sm_q_diag_tail_sc);
#endif

cno_BrInvBreve = (g__comb_inv_breve    g__comb_dbl_inv_breve);
cBrInvBreve_uU = (g__comb_inv_breve_u_u g__comb_dbl_inv_breve_u_u);
cBrInvBreve_uL = (g__comb_inv_breve_u_l g__comb_dbl_inv_breve_u_l);
cBrInvBreve_lL = (g__comb_inv_breve_l_l g__comb_dbl_inv_breve_l_l);

cBridgeDiac = ( g__comb_diaer_u_u  g__comb_diaer_u_l  g__comb_diaer_l_l
				g__comb_inv_breve_u_u  g__comb_inv_breve_u_l  g__comb_inv_breve_l_l
				g__comb_dbl_inv_breve_u_u  g__comb_dbl_inv_breve_u_l  g__comb_dbl_inv_breve_l_l);


// Narrow characters that need a narrow macron.
// Since this subsitution is done in the first pass, we only need to include encoded glyphs.

c_narrowMacron = (g__ltn_sm_i, g__ltn_sm_l, g__ltn_sm_r, g__ltn_sm_t,
	g__ltn_sm_i_grave, g__ltn_sm_i_acute, g__ltn_sm_i_circum, g__ltn_sm_i_diaer, g__ltn_sm_i_tilde, g__ltn_sm_i_macron, g__ltn_sm_i_breve, g__ltn_sm_i_ogonek, g__ltn_sm_dotless_i,
	g__ltn_sm_l_acute, g__ltn_sm_l_cedilla, g__ltn_sm_l_caron, g__ltn_sm_l_middle_dot, g__ltn_sm_l_strk,
	g__ltn_sm_r_acute, g__ltn_sm_r_cedilla, g__ltn_sm_r_caron, g__ltn_sm_t_cedilla, g__ltn_sm_t_caron, g__ltn_sm_t_strk, g__ltn_cap_iota, g__ltn_sm_l_bar, g__ltn_sm_t_hook, g__ltn_sm_i_caron, g__ltn_sm_i_dbl_grave,
	g__ltn_sm_i_inv_breve, g__ltn_sm_r_dbl_grave, g__ltn_sm_r_inv_breve, g__ltn_sm_t_comma_blw,
	g__ltn_sm_l_curl, g__ltn_sm_t_curl // l-curl, t-curl
	g__ltn_sm_r_bar, g__ltn_sm_i_strk, g__ltn_sm_iota, g__ltn_sm_l_middle_tilde, g__ltn_sm_l_belt, g__ltn_sm_l_retr_hook, g__ltn_sm_r_lng_leg, g__ltn_sm_r_fishhook, g__ltn_sm_turned_t, g__ltn_sm_t_retr_hook,
	g__ltn_sm_r_middle_tilde, g__ltn_sm_r_fishhook_middle_tilde, g__ltn_sm_t_middle_tilde, g__ltn_sm_iota_strk,
	g__ltn_sm_r_pal_hook,
	// g1e2d, g1e3d, g1e71, // i-lower-tilde, l-lower-circumflex, t-lower-circumflex
	g__ltn_sm_i_diaer_acute, g__ltn_sm_h_diaer, g__ltn_sm_l_dot_blw_macron, g__ltn_sm_l_line_blw, g__ltn_sm_r_dot_abv, g__ltn_sm_r_dot_blw, g__ltn_sm_r_dot_blw_macron, g__ltn_sm_r_line_blw, g__ltn_sm_t_dot_abv, g__ltn_sm_t_dot_blw, g__ltn_sm_t_line_blw, g__ltn_sm_t_diaer, g__ltn_sm_i_hook_abv,
	g__ltn_sm_i_dot_blw, g__ltn_sm_dbl_barred_l, g__ltn_sm_t_diag_strk, g__ltn_sm_l_high_bar,
	g__ltn_sm_lum, g__ltn_sm_rum, g__ltn_sm_tum // lum, rum, tum??
	g__ltn_sm_insular_f, g__ltn_sm_l_trnd, g__ltn_sm_insular_s, g__ltn_sm_l_retr_hook_belt, g__ltn_sm_r_diag_strk);

c_narrowLowerDiac = (g__comb_lft_half_ring_blw, g__comb_up_tack_blw, g__comb_dwn_tack_blw, g__comb_dot_blw, g__comb_comma_blw, g__comb_cedilla, g__comb_ogonek, g__comb_vert_line_blw, g__comb_bridge_blw, g__comb_dbl_vert_line_blw);

/****
c_narrowMacron = (g_i,
	g_iacute, g_igrave, g_icircumflex, g_idieresis,
	g_i_s_ital, g0456, g2170, g_iacute_s_ital, g_igrave_s_ital, g0209,
	g0209_sItal, g_icircumflex_s_italic, g020b, g020b_sItal, g_ibreve, g_ibreve_s_ital,
	g01d0, g01d0_sItal, g_itilde, g_itilde_s_ital, g_imacron, g_imacron_s_ital,
	g_idieresis_s_ital, g0457, g1e2f, g1e2f_sItal, g_idotaccent, g_idotaccent_s_ital,
	g1ec9, g1ec9_sItal, g1e2d, g1e2d_sItal, g1ecb, g1ecb_sItal, g_iogonek,
	g_iogonek_retro_hook, g0268, g_i_dotless, g_dotlessi_s_ital,
	g_i_dotless_s_ital, g0456_dotless, g1d96_dotless, g0268_dotless, g1d09, g0269, g1d7c,

	g_l, g_l_s_ital, g217c, g2097, g2097_sItal, g02e1, g_lacute, g_lacute_s_ital, g_lcaron_caron, g1e3d,
	g1e3d_sItal, g1e3b, g1e3b_sItal, g1e37, g1e37_sItal, g1e39, g1e39_sItal, g_lcommaaccent,
	g_ldot, g_lcaron, g1d85, g1daa, g019a, ga749, g2c61, g026b, g_lslash, g026d, g1da9, g0234, g026c, ga78e, ga749_sItal,
	ga747, ga781,

	g_r, g_racute, g_rcaron, ga758, g1d514, g1d63, g1dca, g02b3, g036c, g_racute, g0211,
	g0213, g_rcaron, g1e59, g1e5f, g1e5b, g027d_lCStyle, g027c, g02b4, g027b, g02b5,

	g_t, g_tcaron_caron, g1e97, g1e6b, g1e71, g1e6f, g1e6d, g021b, g_tcaron, g0163, g01ab, g1db5,
	g_tbar, g1d75 );


#if (FONT == ANDIKAfont)

c_narrowMacron += (g0269_0301, g0269_0300, g0269_1dc7, g0269_0302, g0269_030c, g0269_0303, g0269_1dc6, g0269_0330,
	g_iogonek_tail_i_retro_hook, g0268_tailI, g0268_dotless_tailI, g_i_tail_i, g_dotlessi_tail_i,
	g_iacute_tail_i, g_igrave_tail_i, g0209_tailI, g_icircumflex_tail_i, g020b_tailI, g_ibreve_tail_i, g01d0_tailI,
	g_itilde_tail_i, g_imacron_tail_i, g1e2f_tailI, g_idieresis_tail_i, g1ec9_tailI, g1e2d_tailI, g1ecb_tailI,
	g_iogonek_tail_i,

	g_lcaron_caron_tail_l, g_l_tail_l, g_lacute_tail_l, g1e3d_tailL, g1e3b_tailL, g1e37_tailL, g1e39_tailL,
	g_lcommaaccent_tail_l, g_ldot_tail_l, g_lcaron_tail_l, g1d85_tailL, g1daa_tailL, g019a_tailL, g2c61_tailL,
	g026b_tailL, g_lslash_tail_l, g026c_tailL,

	g_tcaron_caron_no_tail_t, g0163_commaStyle_noTailT, g_t_no_tail_t, g1e97_noTailT, g1e6b_noTailT,
	g1e71_noTailT, g1e6f_noTailT, g1e6d_noTailT, g021b_noTailT, g_tcaron_no_tail_t, g0163_noTailT,
	g01ab_noTailT, g_tbar_no_tail_t, g1d75_noTailT, g2c66_noTailT);

#endif
****/

endtable; // glyph

// #include "pua.gdh"

#if (FONT == GENTIUMfont)
// Define the class of upper-case letters that need low-profile diacritics.
#include "takes_lowProfile.gdh"

table(glyph) {AttributeOverride = true}

cno_LP { lp_subclass = LP_BASEDIAC };
// The following glyphs have low-profile versions but do not have diacritics attached:
g__ltn_sm_i  { lp_subclass = LP_BASEONLY };
g__ltn_sm_j  { lp_subclass = LP_BASEONLY };
g__ltn_sm_lig_ij { lp_subclass = LP_BASEONLY };
// The following glyphs are just diacritics:
cUDia { lp_subclass = LP_DIACONLY };


// The following are lower-case glyphs with precomposed upper diacritics that have no low-profile equivalents.
// Any diacritics that stack on top of them should be low-profile.
c_lowerWnonLPdiacs = ( g__ltn_sm_a_ring_abv, g__ltn_sm_a_breve, g__ltn_sm_e_breve, g__ltn_sm_g_breve, g__ltn_sm_i_breve, g__ltn_sm_o_breve,
	g__ltn_sm_o_dbl_acute, g__ltn_sm_u_breve, g__ltn_sm_u_dbl_acute, g__ltn_sm_a_dbl_grave, g__ltn_sm_a_inv_breve, g__ltn_sm_e_dbl_grave, g__ltn_sm_e_inv_breve, g__ltn_sm_i_dbl_grave,
	g__ltn_sm_i_inv_breve, g__ltn_sm_o_dbl_grave, g__ltn_sm_o_inv_breve, g__ltn_sm_r_dbl_grave, g__ltn_sm_r_inv_breve, g__ltn_sm_u_dbl_grave, g__ltn_sm_u_inv_breve, g__ltn_sm_e_cedilla_breve, g__ltn_sm_w_ring_abv, g__ltn_sm_y_ring_abv, g__ltn_sm_a_rt_half_ring, g__ltn_sm_a_hook_abv,
	g__ltn_sm_a_breve_dot_blw, g__ltn_sm_e_hook_abv, g__ltn_sm_i_hook_abv, g__ltn_sm_o_hook_abv, g__ltn_sm_o_horn_hook_abv, g__ltn_sm_u_hook_abv, g__ltn_sm_u_horn_hook_abv, g__ltn_sm_y_hook_abv );

endtable;

#endif	// (FONT == GENTIUMfont)


//////////////////////////////////////////////////////////////////////////////////////
//
//	Features
//

#include "features.gdh"


//////////////////////////////////////////////////////////////////////////////////////
//
//	Rules
//

#if (FONT == GENTIUMfont)
// Combine any possible decomposed Greek into composed forms.
#include "greek_recompose.gdh"	// pass 1
#endif


table(substitution);

pass(1)  {MaxBackup = 15; MaxRuleLoop = 30}

// Decomposition/reordering
// Also Greek recomposition is done in pass 1 (in greek_recompose.gdh above).
// Also pitch processing (pitches.gdh).

/* --- removed feature ---
c_pua  >  c_noPua {pua = 1}  /  ^ _ ;
-------------------------- */

// Decompose possible vietnamese base + diac
c_baseCircum  _  >  c_base_noDiac:1  g__comb_circum:1  / ^ _ _;
c_baseBreve   _  >  c_base_noDiac:1  g__comb_breve:1  / ^ _ _;

// For the special bridging diacritic stuff, upper diacritics need to come first so they will attach
// to the first base (0311 and 0361 seem to be treated differently by NFD).
if (bridging_diac)
	cLDblDia  cUDblDia   >   @2  @1;
endif;


// Narrow macrons

if (!smallcaps)
g__comb_macron_blw  >  g__comb_macron_blw_short  /  c_narrowMacron  c_narrowLowerDiac? _ ;
endif;

endpass;  // sub - 1


#if (ANDIKAfamily)
if (smallcaps == 1 || literacy == 1 || literacy_a == 1 || literacy_g == 1 || literacy_old == 0)
#else
if (smallcaps == 1 || literacy == 1 || literacy_a == 1 || literacy_g == 1 || literacy_old == 1)
#endif

pass(2)

// Small-caps, literacy alternates

if (smallcaps)
	cno_sc  > c_sc;
	// cno_smcp > c_smcp;
endif;

// keep Graphite-only litr feature but only apply if other literacy features are off
if (literacy == 0 && literacy_a == 0 && literacy_g == 0)
if (literacy_old == 1)
	cno_SngStory > cSngStory;
	cno_SngBowl  > cSngBowl;
else
	cSngStory > cno_SngStory;
	cSngBowl  > cno_SngBowl;
endif;
endif;

// Note: literacy alternates take precedence over slant-italic feature (below).
// So we can ignore slant-italics here.
if (literacy == 1 || literacy_a == 1)
#if (ANDIKAfamily)
	c_lita > cno_lita;
#else
	cno_lita > c_lita;
#endif
endif;

if (literacy == 1 || literacy_g == 1)
#if (ANDIKAfamily)
	c_litg > cno_litg;
#else
	cno_litg > c_litg;
#endif
endif;

endpass;  // sub - 2


#if (ANDIKAfamily)
endif; // pass constraint: if (smallcaps == 1 || literacy == 1 || literacy_a == 1 || literacy_g == 1 || literacy_old == 0)
#else
endif; // pass constraint: if (smallcaps == 1 || literacy == 1 || literacy_a == 1 || literacy_g == 1 || literacy_old == 1)
#endif

pass(3)  {MaxBackup = 15; MaxRuleLoop = 30}

// Many features: slant italic, Chinantec tones, ogoneks, cedillas, horns, Vietnamese, bridging diacritics,
// engs, ramshorn, mongolian E, short breve, barred bowls, strokes, open-o serif, v-hook, y-hook,
// ezh-curl, t-hook, b-hook, h-stroke, r-tail, p-hook, Romanian, ezh, apostrophe, modifier-low-colon,
// carons, ou, empty-set, cyrillic-shha, serbian, serif-beta, digit variations, Andika variations...
// Also pitch processing (in pitches.gdh).

// TODO: the code below will have to be extended somewhat to correctly handle the case where
// the slant-italic glyphs are the default.

if (slant_italic == 1 || slant_italic__ital == 1)
	// ff, fi, fl ligatures
	g__ltn_sm_f  cfLigC2  >  g__ltn_sm_f_s_ital cfLigC2_sItal   / _ _ cDia;  // don't create a ligature, a following diac stops ligature from forming
	g__ltn_sm_f  cfLigC2  >  _ cfLig_sItal:(1 2) {component {f1.ref = @1; f2.ref = @2}};

	g__ltn_sm_f  g__ltn_sm_f  cffLigC3  >  g__ltn_sm_f_s_ital  g__ltn_sm_f_s_ital  cffLigC3_sItal  / _ _ _ cDia;  // don't create a ligature
	g__ltn_sm_f  g__ltn_sm_f  cffLigC3  >  _ _  cffLig_sItal:(1 2 3) {component {f1.ref = @1; f2.ref = @2; f3.ref = @3}};

	cno_SItal  >  cSItal;		// f, i, l, v
	cno_2StorySItal  >  c2StorySItal;  // a, ae
	// cno_sital > c_sital;
else
	// ff, fi, fl ligatures
	g__ltn_sm_f  cfLigC2  >  @1 @2 / _ _ cDia; // do nothing, a following diac stops ligature from forming
	g__ltn_sm_f  cfLigC2  >  _ cfLig:(1 2) {component {f1.ref = @1; f2.ref = @2}}
		/  _ ^ _ ;	// back up to handle i-alternates

	g__ltn_sm_f  g__ltn_sm_f  cffLigC3  >  @1 @2 @3 / _ _ _ cDia;  // do nothing
	g__ltn_sm_f  g__ltn_sm_f  cffLigC3  >  _ _ cffLig:(1 2 3) {component {f1.ref = @1; f2.ref = @2; f3.ref = @3}}
		/  _  _ ^ _;	// back up to handle i-alternates

	cSItal        >  cno_SItal;
	c2StorySItal  >  cno_2StorySItal;
	// c_sital > cno_sital;
endif;


// Turn combining half-marks into one double-width combining mark
g__comb_dbl_inv_breve_lft=d1  g__comb_dbl_inv_breve_rt=d2  >  g__comb_dbl_inv_breve:(d1 d2) _  /  ^ _  cTakesUDia  DIASTR5(cDia)  _ ;
g__comb_dbl_tilde_lft=d1  g__comb_dbl_tilde_rt=d2  >  g__comb_dbl_tilde:(d1 d2) _  /  ^ _  cTakesUDia  DIASTR5(cDia)  _ ;

// For Chinantec, make the standard Unicode characters look like the special PUA characters.
if (chinantec_tone == 1 || chinantec_tone__chtn == 1)
	cno_ChinantecTn  >  cChinantecTn;
else
	cChinantecTn  >  cno_ChinantecTn;
endif;

// Handle ogoneks; backup needed to also handle literacy feature:
cOgonekBase  g__comb_ogonek  >  cOgonekComposite$1:(b d)  _ {passKeySlot = true}  / ^ _=b  DIASTR4(cnODiaX)  _=d;

// Handle cedillas (including those that need to look like comma-accent by precomposing them);
// back-up needed to also handle rom feature:
cCedillaBase  g__comb_cedilla  >  cCedillaComposite$1:(b d)  _ {passKeySlot = true}  / ^ _=b  DIASTR4(cnHDiaX)  _=d;
// Handle horns:
cHornBase  g__comb_horn  >  cHornComposite$1:(b d)  _ {passKeySlot = true}  /  _=b  DIASTR4(cnRDiaX)  _=d;

// Handle Vietnamese
/* jw comments
     2 stacked diacs go to side-by-side unless there is an intervening upper diac.
     pre-composed base + stacked diacs go to pre-composed base+side-by-side (cVN) */
if (viet == 1 || viet__viet == 1)
	c0302_noVN  cDiac_noVN  >  c_0302_DiacVN$d:(b d)  _  / _=b DIASTR4(cnUDiaX) _=d;
	c0306_noVN  cDiac_noVN  >  c_0306_DiacVN$d:(b d)  _  / _=b DIASTR4(cnUDiaX) _=d;

	cno_VN > cVN;
	// cno_viet > c_viet;
else
	cVN > cno_VN;
	// c_viet > cno_viet;
endif;

table(glyph)
cls_l_lower = (g__ltn_sm_l, g__ltn_sm_l_sc);	// include small caps
cls_o_lower = (g__ltn_sm_o, g__ltn_sm_o_sc);
cls_u_lower = (g__ltn_sm_u, g__ltn_sm_u_sc);
endtable;

if (bridging_diac == 1)
	// LL with bridging diaeresis (U+035F is possible intervening bridging underbar)
	g__comb_diaer  >  g__comb_diaer_u_u  /  g__ltn_cap_l  g__comb_dbl_macron_blw?  _  g__comb_dbl_macron_blw?  g__ltn_cap_l;
	g__comb_diaer  >  g__comb_diaer_u_l  /  g__ltn_cap_l  g__comb_dbl_macron_blw?  _  g__comb_dbl_macron_blw?  cls_l_lower;
	g__comb_diaer  >  g__comb_diaer_l_l  /  cls_l_lower  g__comb_dbl_macron_blw?  _  g__comb_dbl_macron_blw?  cls_l_lower;

	// OU with bridging inverted breve (0311 / 0361)
	cno_BrInvBreve  >  cBrInvBreve_uU  /  g__ltn_cap_o  g__comb_dbl_macron_blw?  _  g__comb_dbl_macron_blw?  g__ltn_cap_u;
	cno_BrInvBreve  >  cBrInvBreve_uL  /  g__ltn_cap_o  g__comb_dbl_macron_blw?  _  g__comb_dbl_macron_blw?  cls_u_lower;
	cno_BrInvBreve  >  cBrInvBreve_lL  /  cls_o_lower  g__comb_dbl_macron_blw?  _  g__comb_dbl_macron_blw?  cls_u_lower;
endif;

#if DEBUG

if (debug == 1)
	g__qstn_mrk > g__digit_one		/ DeBuG g__space g__ltn_sm_e g__ltn_sm_n g__ltn_sm_g g__eq_sgn _ {eng == 0};
	g__qstn_mrk > g__digit_two		/ DeBuG g__space g__ltn_sm_e g__ltn_sm_n g__ltn_sm_g g__eq_sgn _ {eng == 1};
	g__qstn_mrk > g__digit_three	/ DeBuG g__space g__ltn_sm_e g__ltn_sm_n g__ltn_sm_g g__eq_sgn _ {eng == 2};
endif;

#endif  // DEBUG

/*
	NOTES:

	The rules are designed so that they work correctly no matter how the
	default value for a feature is set. While this means the rules don't
	demand that the cmap and feature table agree on the default glyph,
	the font will be more usable in non-GDL apps if they do agree.
	(One exception remaining is vietnamese processing -- so don't
	try to build a font with vietnamese on by default).

	If a glyph name extension (which is what drives the class names) is used
	within more than one feature (e.g., .LrgBowl is used in the Rams horn alternate
	and the Small ezh-curl alternate), then we cannot use the automatically generated
	class names (e.g., cLrgBowl and cno_LrgBowl), but rather must explicitly
	handle each glyph -- sigh.
*/

if (eng == descender && eng__Engs == descender)        // && because it is the default
	// for fonts with default = base, capital, or short:
	c_eng_BaselineHook  >  c_eng_Descender;
	c_eng_UCStyle       >  c_eng_Descender;
	c_eng_Kom           >  c_eng_Descender;
endif;
if (eng == base || (eng__Engs == base && eng__cv43 == descender))
	// for fonts with default = descender, capital, or short:
	c_eng_Descender   >  c_eng_BaselineHook;
	c_eng_UCStyle     >  c_eng_BaselineHook;
	c_eng_Kom         >  c_eng_BaselineHook;
endif;
if (eng == capital || (eng__Engs == capital && eng__cv43 == descender))
	// for fonts with default = descender, base, or short:
	c_eng_Descender    >  c_eng_UCStyle;
	c_eng_BaselineHook >  c_eng_UCStyle;
	c_eng_Kom          >  c_eng_UCStyle;
endif;
if (eng == short || (eng__Engs == short && eng__cv43 == descender))
	// for fonts with default = descender, capital, or base:
	c_eng_Descender    >  c_eng_Kom;
	c_eng_BaselineHook >  c_eng_Kom;
	c_eng_UCStyle      >  c_eng_Kom;
endif;

if (ramshorn == small && ramshorn__ramh == small)
	// for fonts with default = large or gamma
	(g__ltn_sm_rams_horn_lrg_bowl  g__ltn_sm_rams_horn_gamma_style) > g__ltn_sm_rams_horn;
endif;
if (ramshorn == large || (ramshorn__ramh == large && ramshorn__cv25 == small))
	// for fonts with default = small or gamma
	(g__ltn_sm_rams_horn 	g__ltn_sm_rams_horn_gamma_style)	> g__ltn_sm_rams_horn_lrg_bowl;
endif;
if (ramshorn == gamma || (ramshorn__ramh == gamma && ramshorn__cv25 == small))
	// for fonts with default = small or large
	(g__ltn_sm_rams_horn  g__ltn_sm_rams_horn_lrg_bowl)		> g__ltn_sm_rams_horn_gamma_style;
endif

// supernum feature dealt with in pitches.gdh

if (mongol_e == 1 || mongol_e__mone == 1)
	cno_MongolStyle > cMongolStyle;
else
	cMongolStyle >cno_MongolStyle;
endif;

#if 1 // FONT != DOULOSfont
/**** obsolete feature
if (cyr_curs_ital == 1)
	cno_Cursive  >  cCursive;
else
	cCursive  >  cno_Cursive;
endif;
****/
#endif // !DOULOSfont

if (short_breve == 1 || short_breve__sbrv == 1)
	cno_CyShortMrkAlt > cCyShortMrkAlt;
else
	cCyShortMrkAlt > cno_CyShortMrkAlt;
endif;


// --- literacy and slant_italic features moved from here. ---


// The barred_bowl rule must happen *after* the literacy rule
if (barred_bowl == 1 || barred_bowl__bowl == 1)
	cno_barbowl > c_barbowl;
	g__ltn_sm_g_strk > g__ltn_sm_g_bar_bowl;
	g__ltn_sm_g_strk_sng_bowl > g__ltn_sm_g_bar_bowl_sng_bowl;
else
	c_barbowl > cno_barbowl;
	g__ltn_sm_g_bar_bowl > g__ltn_sm_g_strk;
	g__ltn_sm_g_bar_bowl_sng_bowl > g__ltn_sm_g_strk_sng_bowl;
endif;

if (ltnjstroke == doubleSerif || ltnjstroke__Jstk == doubleSerif)
	cno_DblSerif  >  cDblSerif;
else
	cDblSerif  >  cno_DblSerif;
endif;

if (open_o == topSerif || open_o__opnO == topSerif)
	cno_TopSerif  >  cTopSerif;
else
	cTopSerif  >  cno_TopSerif;
endif;

if (v_hook == curved && v_hook__v_hk == curved)  // && becaue it is the default
	c_vhook_StraightLeft >  c_vhook_Curved;
	c_vhook_HighHook     >  c_vhook_Curved;
endif;
if (v_hook == straightLeft || (v_hook__v_hk == straightLeft && v_hook__cv62 == curved))
	c_vhook_Curved    >  c_vhook_StraightLeft;
	c_vhook_HighHook  >  c_vhook_StraightLeft;
endif;
if (v_hook == highHook || (v_hook__v_hk == highHook && v_hook__cv62 == curved))
	c_vhook_Curved       >  c_vhook_HighHook;
	c_vhook_StraightLeft >  c_vhook_HighHook;
endif;

// keep Graphite-only Y_hk feature but only apply if cv68 is off
if (y_hook == 0)
if (y_hook_old == 1)
	cno_RtHookYhook  >  cRtHookYhook;
else
	cRtHookYhook  >  cno_RtHookYhook;
endif;
endif;

if (y_hook == 1)
	cRtHookYhook  >  cno_RtHookYhook;
else
	cno_RtHookYhook  >  cRtHookYhook;
endif;

if (n_hook == 1 || n_hook__N_hk == 1 )
	cno_LCStyleNhook  >  cLCStyleNhook;
else
	cLCStyleNhook  >  cno_LCStyleNhook;
endif;

if (ezh_curl == 1 || ezh_curl__ezhc == 1)
	g__ltn_sm_ezh_curl  >  g__ltn_sm_ezh_curl_lrg_bowl;
else
	g__ltn_sm_ezh_curl_lrg_bowl  >  g__ltn_sm_ezh_curl;
endif;

if (t_hook == 1 || t_hook__t_hk == 1)
	cno_RtHookThook  >  cRtHookThook;
else
	cRtHookThook  >  cno_RtHookThook;
endif;

if (b_hook == 1 || b_hook__B_hk == 1)
	cno_TopBarB  >  cTopBarB;
else
	cTopBarB  >  cno_TopBarB;
endif;

if (d_hook == 1 || d_hook__D_hk == 1)
	cno_TopBarD  >  cTopBarD;
else
	cTopBarD  >  cno_TopBarD;
endif;

if (h_stroke == 1 || h_stroke__Hstk == 1)
	cno_VertStrk  >  cVertStrk;
	////cno_BarStem  >  cBarStem;
else
	cVertStrk  >  cno_VertStrk;
	////cBarStem  >  cno_BarStem;
endif;

if (r_tail == 1 || r_tail__R_tl == 1)
	cno_LCStyleRtail  >  cLCStyleRtail;
else
	cLCStyleRtail  >  cno_LCStyleRtail;
endif;

if (p_hook == 1 || p_hook__p_hk == 1)
	cno_BowlHook  >  cBowlHook;
else
	cBowlHook  >  cno_BowlHook;
endif;

/* --- removed feature ---
if (rom == 1)
	cno_CommaStyle  >  cCommaStyle;
else
	cCommaStyle  >  cno_CommaStyle;
endif;
-------------------------- */

if (ezh == 1 || ezh__Ezhr == 1)
	cno_RevSigmaStyle  >  cRevSigmaStyle;
else
	cRevSigmaStyle  >  cno_RevSigmaStyle;
endif;

// ogonek processing must be in pass 2

if (apostrophe == 1 || apostrophe__apos == 1)
	cno_Lrg  >  cLrg;
else
	cLrg  >  cno_Lrg;
endif;

if (modlowcolon == wide || modlowcolon__coln == wide)
  cno_Wide >  cWide;	// a789, was gf1e9
  //gf1e9  >  gf1e9_wide;
else
  cWide  >  cno_Wide;
  //gf1e9_wide  >  gf1e9;
endif;

if (caron == 0 && caron__carn == 0)  // && because it is the default
	// European caron combinations (feature OFF)
	//if (select_diac)
	//	cno_CaronEuro  g030c  >  _  cCaronEuro$1:(1 2) {comp {base.ref = @1; caron.ref = @2}; passKeySlot=1};
	//else
		cno_CaronEuro  g__comb_caron  >  _  cCaronEuro$1:(1 2) {passKeySlot=1};
	//endif;
endif;
if (caron == 1 || caron__carn == 1)
	// Non-European caron but NFC: decompose and use standard caron
	cCaronEuro  _  >  cno_CaronEuro:1  g__comb_caron:1;
endif;

if (kayan_diacs == 1)
	c_grave_comp _ > c_grave_base g__comb_grave:1 / _ ^ _ g__comb_acute;
	g__comb_grave g__comb_acute > _ g__comb_kayan_grave_acute:(1 2);
	// c_grave_comp g__comb_acute > c_grave_base g__comb_kayan_grave_acute;
else
	g__comb_kayan_grave_acute _ > g__comb_grave g__comb_acute:1;
	// c_grave_base g__comb_kayan_grave_acute > c_grave_comp g__comb_acute;
endif;

if (ou == 1 || ou__opOU == 1)
	cno_OpenTop  >  cOpenTop;
else
	cOpenTop  >  cno_OpenTop;
endif;

if (emptyset == 1 || emptyset__empt == 1)
	cno_SlashZero  >  cSlashZero;
else
	cSlashZero  >  cno_SlashZero;
endif;

/* --- Obsolete feature ---
if (ltnglottalstop == capHeight)
  g0294_lC  >  g0294;
else
  g0294  >  g0294_lC;
endif;
--------------------------- */

if (cyrillic_shha == 1 || cyrillic_shha__shha == 1)
	cno_UCStyleCyrShha  >  cUCStyleCyrShha;
else
	cUCStyleCyrShha  >  cno_UCStyleCyrShha;
endif;

if (serbian == 1 || serbian__locl == 1)
	cno_Serb  >  cSerb;
else
	cSerb  >  cno_Serb;
endif;

#if (FONT == GENTIUMfont)

if (serif_beta == 1 || serif_beta__beta == 1)
	cno_Serif  >  cSerif;
else
	cSerif  >  cno_Serif;
endif;

if (greek_circ == 1 || greek_circ__pcir == 1)
	cno_Por  >  cPor;
else
	cPor  >  cno_Por;
endif;

#endif // GENTIUMfont

#if (ANDIKAfamily)

if (zero == 1 || zero__dig0 == 1)
	cno_Slash  >  cSlash;
else
	cSlash  >  cno_Slash;
endif;

if (one == 1 || one__dig1 == 1)
	cno_NoBase  >  cNoBase;
else
	cNoBase  >  cno_NoBase;
endif;

if (four == 1 || four__dig4 == 1)
	cno_Open  >  cOpen;
else
	cOpen  >  cno_Open;
endif;

if (six_nine == 1 || six_nine__dg69 == 1)
	cno_Diag  > cDiag;
else
	cDiag  >  cno_Diag;
endif;

if (seven == 1 || seven__dig7 == 1)
	cno_Bar  >  cBar;
else
	cBar  >  cno_Bar;
endif;

if (i_hook == 1 || i_hook__i_tl == 1)
	cno_TailI  >  cTailI;
else
	cTailI  >  cno_TailI;
endif;

if (j_serif == 1 || j_serif__jser == 1)
	cno_TopLftSerif  >  cTopLftSerif;
else
	cTopLftSerif  >  cno_TopLftSerif;
endif;

// No-Tail-T, Tail-L - see below

if (q_diagtail == 1 || q_diagtail__Qalt == 1)
	cno_DiagTail  >  cDiagTail;
else
	cDiagTail  >  cno_DiagTail;
endif;

if (q_point == 1 || q_point__q_tl == 1)
	cno_Point  >  cPoint;
else
	cPoint  >  cno_Point;
endif;


if (y_tail == 1 || y_tail__y_tl == 1)
	cno_NoTailY  > cNoTailY;
else
	cNoTailY  >  cno_NoTailY;
endif;

#endif	// ANDIKAfamily

endpass;  // sub - 3


pass(4)  {MaxBackup = 15; MaxRuleLoop = 30}	// substitution

// Low-profile diacritics, more Andika features, dotless i + diac, ogonek, superscript/subscript diac,...


#if (FONT == GENTIUMfont)

// Low-profile diacritics--do this after processing Vietnamese.

// All stacking diacritics should be low-profile.
// In each of these rules we back up to handle dotless stuff.

// Mark the upper diacritic as needing low-profile because it is in a stack:
cno_LP  cUDia  >  cLP  @U {needs_lp = 1}  / ^ _ {lp_subclass == LP_DIACONLY}  DIASTR4(cnUDiaX)  _=U;
cno_LP  >  cLP  /  ^ _ {needs_lp == 1};  // needs LP because it follows an LP-diac from rule above
cno_LP  >  cLP  /  cUDia ^ _ {lp_subclass == LP_DIACONLY};
cno_LP  >  cLP  / c_lowerWnonLPdiacs ^ _;	// eg, NFC e-breve+circumflex, w-ring+acute

// Make sure to use low-profile diacritics on any decomposed uppercase.
cno_LP  >  cLP  /  cTakesLPDiac  DIASTR4(cnUDiaX) ^ _ {lp_subclass == LP_DIACONLY} ;

// Don't try to do low-profile stuff with small-caps.
if ((low_profile_diac || low_profile_diac__lopr) && !smallcaps)
	cno_LP  >  cLP  / ^ _;	// back up to handle dotless stuff
endif;

// Gentium features that interact with other features

if (iota_subscript == 1)
	cno_ISub  >  cISub;
else
	cISub  >  cno_ISub;
endif;

#endif // GENTIUMfont


#if (ANDIKAfamily)

// Andika features that interact with other features

if (t_tail == 1 || t_tail__t_tl == 1)
	cno_NoTailT  >  cNoTailT;
else
	cNoTailT  >  cno_NoTailT;
endif;

if (l_hook == 1 | l_hook__l_tl == 1)
	cno_TailL  >  cTailL;
else
	cTailL  >  cno_TailL;
endif;

#endif // ANDIKAfamily


// Convert i to dotless i when followed by upper diacritic.

// decomposed sequences:
cno_Dotless  cUDia=D  >  cDotless  @D {passKeySlot=1}  /  _  ^  DIASTR4(cnUDiaX)  _=D;
// precomposed chars with i are done by decomposition:
cSpecialDotted  _  cUDia=D  >  g__ltn_sm_i_dotless  cSpecialDottedDia$1:1  @D {passKeySlot=1}
	/  _  _  ^  DIASTR4(cnUDiaX)  _=D;

// Now that ogonek has been composed with its vowels, do retrohook style if wanted:

if (ogonek == americanist || ogonek__ogon == americanist)
	cno_RetroHook > cRetroHook;
else
	cRetroHook > cno_RetroHook;
endif;

//	g__aogonek	> g__a g0328_retroHook:1;
//	g_aogonek	> g_a  g0328_retroHook:1;
//	g__eogonek	> g__e g0328_retroHook:1;
//	g_eogonek	> g_e  g0328_retroHook:1;
//	g__iogonek	> g__i g0328_retroHook:1;
//	g_iogonek_dotless > g_i_dotless g0328_retroHook:1;
//	g_iogonek	> g_i  g0328_retroHook:1;
//	g__uogonek	> g__u g0328_retroHook:1;
//	g_uogonek	> g_u  g0328_retroHook:1;
//	g01ea		> g__o g0328_retroHook:1;
//	g01eb		> g_o  g0328_retroHook:1;
//	g01ec		> g__omacron g0328_retroHook:1;
//	g01ed		> g_omacron  g0328_retroHook:1;
//	g_ogonek	> g_ogonek_retro_hook:1;
//	g0328		> g0328_retroHook:1;
//endif;


// Handle superscript/subscript diacritics; currently the only one of interest is a diaeresis:
cno_Sup  >  cSup  /  (cModSuper cModSub)  _;


/* --- removed feature ---
// Deprecated PUA

if (dep_pua == unicode51)
	cno_Dep51  >  cDep51  /  _ {pua==1};
endif;
if (dep_pua == unicode50)
	cno_Dep50  >  cDep50  /  _ {pua==1};
endif;
if (dep_pua == unicode41)
	cno_Dep41  >  cDep41  /  _ {pua==1};
endif;
if (dep_pua == unicode40)
	cno_Dep40  >  cDep40  /  _ {pua==1};
endif;
-------------------------- */


endpass;  // sub - 4


endtable; // substitution


#include "pitches.gdh"


table(positioning) {MUnits = 1000};

// Handle attachments

pass(1)

#define pos_rule(t, x, a, w, n) t x {attach {to = @1; at = a; with = w}; attached = 1} / ^ _ DIASTR4(n) _{attached == 0}
#define pos_ruleSD(t, x, a, w, n) t x {attach {to = @1; at = a; with = w}; insert = 1; attached = 1} / ^ _ DIASTR4(n) _{attached == 0}


//if (select_diac)
//	pos_ruleSD(cTakesHDia, cHDia, HS, HM, cnHDiaX);
//	pos_ruleSD(cTakesLDia, cLDia, LS, LM, cnLDiaX);
//	pos_ruleSD(cTakesODia, cODia, OS, OM, cnODiaX);
//	pos_ruleSD(cTakesRDia, cRDia, RS, RM, cnRDiaX);
//	pos_ruleSD(cTakesUDia, cUDia, US, UM, cnUDiaX);
//else
	pos_rule(cTakesHDia, cHDia, HS, HM, cnHDiaX);
	pos_rule(cTakesLDia, cLDia, LS, LM, cnLDiaX);
	pos_rule(cTakesODia, cODia, OS, OM, cnODiaX);
	pos_rule(cTakesRDia, cRDia, RS, RM, cnRDiaX);
	pos_rule(cTakesUDia, cUDia, US, UM, cnUDiaX);
//endif;


// Bridge diacritics handled by attachment need to have zero advance width,
// otherwise they push the second character out and away. (This wouldn't work if above
// we didn't reprocess attached diacritics using the ^ mechanism.)
cBridgeDiac {advance.x = 0};

endpass; // pos - 1


// Handle double-diacritics

pass(2)	// positioning

	// Double-diacritics above: the ".1" gives the bounding box of the attached cluster of
	// base + diacritics.

	// Something on both sides:
	cUDblDia {shift.y = max(@B.boundingbox.top.1, @A.boundingbox.top.1) - @D.boundingbox.bottom + 100m ;
			shift.x = (@A.boundingbox.width.1 - @B.boundingbox.width.1)/2; insert = 1}
			/ cTakesUDia=B  DIASTR3(cDia)  cLDblDia?  _=D  DIASTR3(cDia)  cTakesUDia=A;
	// Beginning of line:
	cUDblDia {shift.y = @B.boundingbox.top.1 - @D.boundingbox.bottom + 100m ; insert = 1}
			/ cTakesUDia=B  DIASTR5(cDia)  cLDblDia?  _=D;
	// End of line:
	cUDblDia {shift.y = @A.boundingbox.top.1 - @D.boundingbox.bottom + 100m ; insert = 1}
			/ DIASTR5(cDia)  cLDblDia?  _=D  cTakesUDia=A;

endpass; // pos - 2


pass(3)

	// Double-diacritics below:

	// Special case for two bridging diacritics:
	g__comb_dbl_macron_blw {shift.y = min(@B.boundingbox.bottom.1, @A.boundingbox.bottom.1) - @D.boundingbox.top -100m ;
		  shift.x = (@A.boundingbox.width - @B.boundingbox.width)/2; insert = 1}
		  / cTakesLDia=B  DIASTR3(cDia)  cUDblDia?  _=D  cUDblDia?  DIASTR3(cDia)  cTakesLDia=A;
	cLDblDia {shift.y = min(@B.boundingbox.bottom.1, @A.boundingbox.bottom.1) - @D.boundingbox.top -100m ;
		  shift.x = (@A.boundingbox.width.1 - @B.boundingbox.width.1)/2; insert = 1}
		  / cTakesLDia=B  DIASTR3(cDia)  cUDblDia?  _=D  cUDblDia?  DIASTR3(cDia)  cTakesLDia=A;
	cLDblDia {shift.y = @B.boundingbox.bottom.1 - @D.boundingbox.top -100m ; insert = 1}
			/ cTakesLDia=B  DIASTR5(cDia)  cUDblDia?  _=D ;
	cLDblDia {shift.y = @A.boundingbox.bottom.1 - @D.boundingbox.top -100m ; insert = 1}
			/ DIASTR5(cDia)  cUDblDia?  _=D  cTakesLDia=A ;


endpass; // pos - 3

////#include "kern.gdh"

endtable; // positioning
